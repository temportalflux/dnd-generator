import lodash from 'lodash';
import inlineEval from './modules/evalAtCtx';
import parser from './parser';

class GenerationEntry
{

	constructor(category, keyInCategory, { source, dependencies, stringify, canReroll, children })
	{
		this.category = category;
		this.keyInCategory = keyInCategory;
		this.source = source;
		this.parent = undefined;

		// list of entries that regenerating this entry will cause to regenerate
		this.affects = [];

		this.dependencies = dependencies;

		this.children = children || {};
		this.childEntries = {};

		// Whatever the current value of this object is
		this.value = children ? {} : undefined;

		// An object with keys to other fields and whose values are the addition/subtractions used to modify that value
		this.modifiers = undefined;

		this.metadata = {
			stringify: stringify,
			canReroll: canReroll,
		};
	}

	getKey()
	{
		return `${this.category}.${this.keyInCategory}`;
	}

	setParent(parent)
	{
		this.parent = parent;
	}

	hasChildren()
	{
		return Object.keys(this.childEntries).length > 0;
	}

	setChild(childKey, entry)
	{
		this.childEntries[childKey] = entry;
	}

	addAffectiveEntry(key)
	{
		this.affects.push(key);
	}

	getAffectiveEntries()
	{
		return [
			...this.getChildrenKeysGlobal(),
			...this.affects,
		];
	}

	getChildren()
	{
		return this.children;
	}

	getChildrenKeysGlobal()
	{
		return Object.keys(this.getChildren()).map((key) => `${this.getKey()}.${key}`);
	}

	getValue()
	{
		if (!this.hasChildren())
		{
			return this.value;
		}

		return lodash.mapValues(this.childEntries, (entry) => entry.getValue());
	}

	hasValue()
	{
		return this.value !== undefined;
	}

	compileData()
	{
		return lodash.values(this.childEntries).reduce((accum, entry) => ({
			...accum,
			...entry.compileData(),
		}), {
			[this.getKey()]: this.getValue(),
		});
	}

	stringify()
	{
		if (this.metadata.stringify)
		{
			return inlineEval(this.metadata.stringify, this.value);
		}
		return JSON.stringify(this.value);
	}

	generate(data)
	{
		if (this.source === undefined) return;

		if (this.dependencies)
		{
			for (const dependencyKey of this.dependencies)
			{
				if (!data.hasOwnProperty(dependencyKey)) return;
			}
		}

		console.log(this.source, lodash.cloneDeep(data));
		// Parser could return an undefined value if the command didn't work.
		// For example, a table like 'beard' is assumed to have an entry for every race,
		// so races can opt-in by defining a beard.json table. If one is missing, this is not an error,
		// but rather the race opting-out of generating beard data.
		const result = parser(this.source, data);
		console.log(result);
		if (typeof result === 'object' && !Array.isArray(result))
		{
			this.value = result.value;
			this.modifiers = result.modifiers;
		}
		else
		{
			this.value = result;
			this.modifiers = undefined;
		}
	}

}

export default class Generator
{

	constructor()
	{
		this.categories = {};
	}

	hasCategory(category)
	{
		return this.categories.hasOwnProperty(category);
	}

	getCategoryAndSubkeyFrom(fullKey)
	{
		const category = lodash.toPath(fullKey)[0];
		return {
			category: category,
			keyInCategory: fullKey.slice(category.length + 1),
		};
	}

	// TODO: hasEntry and getEntry should query the parent entries for their children - entries with parents are no longer stored in the category hierarchy

	hasEntry(fullKey)
	{
		const {category, keyInCategory} = this.getCategoryAndSubkeyFrom(fullKey);
		return this.hasCategory(category) && this.categories[category].hasOwnProperty(keyInCategory)
	}

	getEntry(fullKey)
	{
		const {category, keyInCategory} = this.getCategoryAndSubkeyFrom(fullKey);
		return this.categories[category][keyInCategory];
	}

	createField(category, key, field)
	{
		const entry = new GenerationEntry(category, key, field);

		if (entry.dependencies)
		{
			for (const dependencyKey of entry.dependencies)
			{
				if (!this.hasEntry(dependencyKey))
				{
					throw new Error(`Cannot create dependency from '${entry.getKey()}' on '${dependencyKey}', there is no entry for '${dependencyKey}'.`);
				}
				this.getEntry(dependencyKey).addAffectiveEntry(entry.getKey());
			}
		}

		const children = entry.getChildren();
		const childrenKeys = Object.keys(children);
		if (childrenKeys.length > 0)
		{
			for (const childKey of childrenKeys)
			{
				const childEntry = this.createField(category, `${entry.keyInCategory}.${childKey}`, children[childKey]);
				childEntry.setParent(entry);
				entry.setChild(childKey, childEntry);
			}
		}

		return entry;
	}

	// key - the key path i.e. 'a.b[3].c'
	// template - the text in the json used to cause a generation i.e. "{roll:race/$(description.race)/hair}"
	// dependencies - any other entries that would cause this entry to be regenerated by (i.e. ["description.race"])
	// The fields this depends on must already exist in the generator
	addField(category, key, field)
	{
		const entry = this.createField(category, key, field);
		
		if (!this.hasCategory(entry.category))
		{
			this.categories[entry.category] = {};
		}
		this.categories[entry.category][entry.keyInCategory] = entry;

		return entry;
	}

	compileData()
	{
		return lodash.values(this.categories).reduce(
			(accum, categoryEntries) => ({
				...accum,
				...lodash.toPairs(categoryEntries)
					.filter(([_, entry]) => entry.hasChildren() || entry.hasValue())
					.reduce((accumCate, [_, entry]) => ({
						...accumCate,
						...entry.compileData()
					}), {})
			}), {}
		);
	}

	// causes a generation of the entry at key
	regenerate(key, bGenerateDependencies = true)
	{
		const category = lodash.toPath(key)[0];
		const keyInCategory = key.slice(category.length + 1);

		if (!this.hasCategory(category) || !this.categories[category].hasOwnProperty(keyInCategory))
		{
			throw new Error(`Missing entry '${key}', please add it via 'addField'.`);
		}

		const entry = this.categories[category][keyInCategory];
		entry.generate(this.compileData());

		if (bGenerateDependencies)
		{
			let affectiveEntryKeys = entry.getAffectiveEntries();
			for (const affectedEntryKey of affectiveEntryKeys)
			{
				this.regenerate(affectedEntryKey, true);
			}
		}

	}

}