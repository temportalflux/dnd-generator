import lodash from 'lodash';
import inlineEval from './modules/evalAtCtx';
import parser from './parser';

class GenerationEntry
{

	constructor(key, { source, dependencies, stringify, canReroll, children })
	{
		this.key = key;
		this.source = source;
		this.parent = undefined;

		// list of entries that regenerating this entry will cause to regenerate
		this.affects = [];

		this.dependencies = dependencies;

		this.children = (children || []).map((childKey) => `${key}.${childKey}`);

		// Whatever the current value of this object is
		this.value = children ? {} : undefined;

		// An object with keys to other fields and whose values are the addition/subtractions used to modify that value
		this.modifiers = undefined;

		this.metadata = {
			stringify: stringify,
			canReroll: canReroll,
		};
	}

	setParent(parent)
	{
		this.parent = parent;
	}

	setChildValue(childKey, value)
	{
		this.value[childKey.slice(this.key.length + 1)] = value;
		if (this.parent)
		{
			this.parent.setChildValue(this.key, this.value);
		}
	}

	addAffectiveEntry(key)
	{
		this.affects.push(key);
	}

	getAffectiveEntries()
	{
		return [
			...this.children,
			...this.affects,
		];
	}

	getChildren()
	{
		return this.children;
	}

	stringify()
	{
		if (this.metadata.stringify)
		{
			return inlineEval(this.metadata.stringify, this.value);
		}
		return JSON.stringify(this.value);
	}

	generate(data)
	{
		if (this.source === undefined) return;

		if (this.dependencies)
		{
			for (const dependencyKey of this.dependencies)
			{
				if (!data.hasOwnProperty(dependencyKey)) return;
			}
		}

		console.log(this.source, lodash.cloneDeep(data));
		// Parser could return an undefined value if the command didn't work.
		// For example, a table like 'beard' is assumed to have an entry for every race,
		// so races can opt-in by defining a beard.json table. If one is missing, this is not an error,
		// but rather the race opting-out of generating beard data.
		const result = parser(this.source, data);
		console.log(result);
		if (typeof result === 'object' && !Array.isArray(result))
		{
			this.value = result.value;
			this.modifiers = result.modifiers;
		}
		else
		{
			this.value = result;
			this.modifiers = undefined;
		}

		if (this.parent)
		{
			this.parent.setChildValue(this.key, this.value);
		}
	}

}

export default class Generator
{

	constructor()
	{
		this.entries = {};
	}

	// key - the key path i.e. 'a.b[3].c'
	// template - the text in the json used to cause a generation i.e. "{roll:race/$(description.race)/hair}"
	// dependencies - any other entries that would cause this entry to be regenerated by (i.e. ["description.race"])
	// The fields this depends on must already exist in the generator
	addField(key, allData)
	{
		const field = allData[key];
		this.entries[key] = new GenerationEntry(key, field);
		const entry = this.entries[key];
		
		if (field.dependencies)
		{
			for (const dependencyKey of field.dependencies)
			{
				if (!this.entries.hasOwnProperty(dependencyKey))
				{
					throw new Error(`Cannot create dependency from '${key}' on '${dependencyKey}', there is no entry for '${dependencyKey}'.`);
				}
				this.entries[dependencyKey].addAffectiveEntry(key);
			}
		}

		const children = entry.getChildren();
		if (children.length > 0)
		{
			for (const childKey of children)
			{
				const childEntry = this.addField(childKey, allData);
				childEntry.setParent(entry);
			}
		}

		return entry;
	}

	compileData()
	{
		return Object.keys(this.entries).filter((key) => this.entries[key].value !== undefined).map((key) => this.entries[key].value);
	}

	// causes a generation of the entry at key
	regenerate(key, bGenerateDependencies = true)
	{
		if (!this.entries.hasOwnProperty(key))
		{
			throw new Error(`Missing entry '${key}', please add it via 'addField'.`);
		}

		const entry = this.entries[key];
		console.log(key);
		entry.generate(this.compileData());

		if (bGenerateDependencies)
		{
			let affectiveEntryKeys = entry.getAffectiveEntries();
			for (const affectedEntryKey of affectiveEntryKeys)
			{
				this.regenerate(affectedEntryKey, true);
			}
		}

	}

}